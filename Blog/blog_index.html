<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-10-26 Thu 12:27 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="author" content="Amery Gration" />
<meta name="generator" content="Org Mode" />
<meta charset="UTF-8" />
<link rel="stylesheet" href="../Css/style.css" />
<link rel="stylesheet" href="../Css/blog_typesetting.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="icon" type="image/x-icon" href="../Images/argentum.png">

<!-- Google tag (gtag.js). See https://analytics.google.com/analytics/web/#/a181402249p250590135/admin/streams/table/ -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-F9PBCHZCLR"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-F9PBCHZCLR');
</script>
</head>
<body>
<div id="preamble" class="status">
<!-- Preamble -->
<!-- The header -->
<div class="header">

  <!-- The site name -->
  <div class="site-name">
    <a href="/">Amery Gration</a>
  </div>
  
  <!-- The hamburger -->
  <div class="hamburger">

    <div id="myLinks" class="menu">
	  <a href="/">About</a>
	  <a href="/research.html">Research</a>
	  <!-- <a href="/teaching.html">Teaching</a> -->
	  <a href="/blog.html">Blog</a>
	  <a href="/contact.html">Contact</a>
    </div>

    <a href="javascript:void(0);" class="icon" onclick="myFunction()">
      <i class="fa fa-bars"></i>
    </a>
    
  </div>
  
  <div class="navbar">
    <a href="/">About</a>
    <a href="/research.html">Research</a>
    <!-- <a href="/teaching.html">Teaching</a> -->    
    <a href="/blog.html">Blog</a>
    <a href="/contact.html">Contact</a>
  </div>

</div>

<!-- The hamburger menu  -->
<script>
  function myFunction() {
      var x = document.getElementById("myLinks");
      if (x.style.display === "block") {
	  x.style.display = "none";
      } else {
	  x.style.display = "block";
      }
  }
</script>
</div>
<div id="content" class="content">

<div id="outline-container-org0543b83" class="outline-2">
<h2 id="org0543b83"><a href="python_functions_taking_float_and_array-like_arguments.html">Python functions taking float and array-like arguments</a></h2>
<div class="outline-text-2" id="text-org0543b83">
<div class="published" id="org95114b3">
<p>
Published on Thursday 26 October 2023 at 13:00 BST
</p>

</div>
<p>
I often find myself wanting to write a Python function that accepts scalars and array-like objects for each argument. In these cases I have to make a decision about that function's return type. Typically the function performs Numpy operations on the arguments passed to it. But the return type of Numpy functions often surprises me. If a scalar or 0d array-like object is passed to such a Numpy function then it returns a `numpy.float64` object. Only otherwise does it return a `numpy.object` ndarray. For example, using `numpy.sin` we find the following.
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; w = np.sin(1); x = np.sin(1.); y = np.sin(np.array(1.)); z = np.sin([1., 1.])
&gt;&gt;&gt; type(w); type(x); type(y); type(z)
&lt;class 'numpy.float64'&gt;
&lt;class 'numpy.float64'&gt;
&lt;class 'numpy.float64'&gt;
&lt;class 'numpy.ndarray'&gt;
</pre>
</div>

<p>
Any operation on a `numpy.float64` object returns another `numpy.float64` object. More surprisingly, any operation on a 0d `numpy.ndarray` object also returns a `numpy.float64` object. Even multiplying by one does this. 
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; x = np.array(1.)
&gt;&gt;&gt; x; type(x); x.ndim; x.shape
array(1.)
&lt;class 'numpy.ndarray'&gt;
0
()
&gt;&gt;&gt; x = 1.*x
&gt;&gt;&gt; x; type(x); x.ndim; x.shape
1.0
&lt;class 'numpy.float64'&gt;
0
()
</pre>
</div>

<p>
So what should I do? A home-made function that is just some sequence of Numpy functions will always behave in the same way. Let's imagine tha I define such a function, `func`.
</p>

<div class="org-src-container">
<pre class="src src-python">def func(x):
    return some_function_of(x)
</pre>
</div>

<p>
However, there is a good case to be made for a function always returning the same type of object, in this case a `numpy.ndarray`. To do so we must stop floats and 0d arrays from being returned as `numpy.float64` objects. The trick is to cast both of these types as 1d `numpy.ndarray` objects and then squeeze them to become 0d `numpy.ndarray` objects. This code does the trick.
</p>

<div class="org-src-container">
<pre class="src src-python">def func(x):
    if np.isscalar(x):
        x = np.atleast_1d(x)
        scalar_flag = True
    else:
        scalar_flag = False

    res = some_function_of(x)

    if scalar_flag:
        return res.squeeze()

    return res
</pre>
</div>

<p>
In this way, scalar and 0d array-like arguments become 0d Numpy arrays. Other arguments become Numpy arrays while preserving their dimension. Let's say that `some<sub>function</sub><sub>of</sub>(x)` is `np.log(x)`. The Numpy function itself works as follows.
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; x = np.log(1.)
&gt;&gt;&gt; x; type(x); x.ndim; x.shape
0.0
&lt;class 'numpy.float64'&gt;
0
()
&gt;&gt;&gt; x = log([1.])
&gt;&gt;&gt; x; type(x); x.ndim; x.shape
array([1.])
&lt;class 'numpy.ndarray'&gt;
1
(1,)
</pre>
</div>

<p>
But `func` works differently.
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; x = func(1.)
&gt;&gt;&gt; x; type(x); x.ndim; x.shape
array(0.)
&lt;class 'numpy.ndarray'&gt;
0
()
&gt;&gt;&gt; x = func([1.])
&gt;&gt;&gt; x; type(x); x.ndim; x.shape
array([0.])
&lt;class 'numpy.ndarray'&gt;
1
(1,)
</pre>
</div>

<p>
However, I prefer my functions to be consistent with Numpy's, so I need not worry about any of this. But this occasionally leaves me with another problem. Suppose that inside my function I wish to perform some check on the arguments. Let's say that my function takes two arguments and that I want to check that the first is compatible with second. I might coerce both arguments into being Numpy arrays and then compare their shapes.
</p>

<div class="org-src-container">
<pre class="src src-python">def func(x, y):
    x = np.asarray(x)
    y = np.asarray(y)
    if not x.shape == y.shape:
        raise ValueError("message.")

    return x
</pre>
</div>

<p>
The function works as follows.
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; func(1., 1.)
array(1.)
&gt;&gt;&gt; func([1.], [1.])
array([1.])
&gt;&gt;&gt; func(1., [1.])
ValueError: message.
&gt;&gt;&gt; func([1.], [1., 1])
ValueError: message.
</pre>
</div>

<p>
But if I want my function to be consistent with Numpy then casting scalars to arrays (i.e. promoting the dimension of an object) is exactly what I want to avoid doing. Having promoted the dimensions `x` and `y` I am stuck with Numpy arrays. I might try to extract the elements of `x` and `y` using `x.item()` and `y.item()` but this gives me Python `float` objects, not Numpy `numpy.float64` objects. The trick this time is to treat scalars and array-like objects separately and to coerce the array-like objects into being Numpy arrays instead of coercing the floats as we did before.
</p>

<div class="org-src-container">
<pre class="src src-python">def func(x, y):
    if np.isscalar(x) and np.isscalar(y):
        return x
    else:
        x = np.asarray(x)
        y = np.asarray(y)
    if x.shape == y.shape:
        return x
    else:
        raise ValueError("message.")
</pre>
</div>

<p>
This behaves how I want it to.
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; func(1., 1.)
1.
&gt;&gt;&gt; func([1.], [1.])
array([1.])
&gt;&gt;&gt; func(1., [1.])
ValueError: message.
&gt;&gt;&gt; func([1.], [1., 1])
ValueError: message.
</pre>
</div>

<p>
Much better.
</p>

<p>
<i>The users of Stack Overflow helped me get my head straight on this by answering <a href="https://stackoverflow.com/questions/77359660/why-does-operating-on-a-0d-numpy-array-give-a-numpy-float">this question</a> of mine.</i>
</p>
</div>
</div>

<div id="outline-container-orgbd63683" class="outline-2">
<h2 id="orgbd63683"><a href="backing_up_your_linux_machine.html">Backing up your Linux machine</a></h2>
<div class="outline-text-2" id="text-orgbd63683">
<div class="published" id="org8d0c10c">
<p>
Published on Saturday  8 April 2023 at 12:00 BST
</p>

</div>
<p>
<i>I wrote the following advice for members of the Astrophysics Research Group at the University of Surrey. I publish it here, unchanged, in the hope that it might be of use to others too.</i>
</p>

<p>
The University does not provide automated backup of Linux machines, but instead leaves you to worry about this yourself.
I suspect that most Linux users back up their data in a happy-go-lucky way, using GitLab and external storage, performing commits and file transfers only
when they remember.
But with some intermediate-level Bash tinkering you can arrange for full backups to be made automatically to a schedule.
Setting this up should take half an hour or so.
The first backup will take considerably longer but will not need your attention (my home drive is currently 180 Gb in size and took 15 hrs to first backup) while subsequent backups will take only minutes.
</p>

<div class="morelink" id="orgce2aec9">
<p>
<a href="backing_up_your_linux_machine.html">Read More</a>
</p>

</div>
</div>
</div>


<div id="outline-container-org0ff3907" class="outline-2">
<h2 id="org0ff3907"><a href="citation_handling_in_emacs.html">Citation handling in Emacs</a></h2>
<div class="outline-text-2" id="text-org0ff3907">
<div class="published" id="org1bb3629">
<p>
Published on Wednesday  5 April 2023 at 12:00 BST
</p>

</div>
<p>
Until recently Emacs's Org mode had no native support for citation handling, which was done by third-party packages such as Org Ref.
But as of Org version 9.5, <a href="https://orgmode.org/worg/org-release-notes.html">released</a> in October 2021, native citation handling has been provided by the built-in library Org Cite.
Org Cite is intentionally basic, providing no more than core citation-handling functionality.
On its own it has nothing like the capabilities of Org Ref.
But it can be extended (this is Emacs, after all) with the Citar package.
In turn, further packages can be used to enhance the combined functionality and appearance of Org Cite and Citar.
Together these provide a near-complete citation-handling framework for Org.
</p>

<div class="morelink" id="org0991234">
<p>
<a href="citation_handling_in_emacs.html">Read More</a>
</p>

</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div class="footer">
  <hr><br><br>
  Made with Emacs 29.1 (Org mode 9.6.6).
  Last updated on Thursday 26 October 2023 <br>
  Copyright © 2023 Amery Gration<br><br>
  <!-- <a href="/contact.html" -->
  <!--   <i class="fa fa-info-circle" style="font-size:36px;color:gray"></i> -->
  <!-- </a> -->
  <a href="https://twitter.com/amerygration"
    <i class="fa fa-twitter" style="font-size:36px;color:gray"></i>
  </a>
  <a href="https://github.com/AmeryGration"
    <i class="fa fa-github" style="font-size:36px;color:gray"></i>
  </a><br><br>
</div>
</div>
</body>
</html>